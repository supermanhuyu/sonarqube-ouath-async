package sonarqube

import (
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"io/ioutil"
	"mime/multipart"
	"net/http"
	"net/url"
	"strconv"
	"strings"

	"sonarqube-ouath-async/flag"
	"sonarqube-ouath-async/log"
	"sonarqube-ouath-async/models/sonar"
)

type Paging struct {
	PageIndex int `json:"pageIndex"`
	PageSize  int `json:"pageSize"`
	Total     int `json:"total"`
}

type Groups struct {
	ID           string `json:"id"`
	Name         string `json:"name"`
	Description  string `json:"description"`
	MembersCount int    `json:"membersCount"`
	Default      bool   `json:"default"`
}

func SearchGroup() (response map[string]string) {
	// TODO

	type AutoGenerated struct {
		Paging Paging   `json:"paging"`
		Groups []Groups `json:"groups"`
	}

	result := make(map[string]string)
	page := 1
	pageSize := 100
	for {
		url := flag.SonarAddr + "/api/user_groups/search?q=&p=" + strconv.Itoa(page) + "&ps=" + strconv.Itoa(pageSize)
		req, _ := http.NewRequest("GET", url, nil)
		req.Header.Add("Authorization", flag.SonarToken)

		resp, err := (&http.Client{}).Do(req)
		if err != nil {
			log.Logger.Error("Failed to query user group" + err.Error())
			return result
		}
		defer resp.Body.Close()
		respByte, _ := ioutil.ReadAll(resp.Body)
		var resultType AutoGenerated
		json.Unmarshal(respByte, &resultType)
		for _, e := range resultType.Groups {
			result[e.Name] = e.ID
		}
		if page*pageSize >= resultType.Paging.Total {
			break
		}
		page++
	}
	return result

}

func CreatGroup(name string, description string) {
	// TODO
	method := "POST"
	v := url.Values{}
	v.Add("description", description)
	v.Add("name", name)
	reqUrl := flag.SonarAddr + "/api/user_groups/create?" + v.Encode()

	client := &http.Client{}
	req, err := http.NewRequest(method, reqUrl, nil)
	if err != nil {
		fmt.Println(err)
		return
	}
	req.Header.Add("Authorization", flag.SonarToken)
	res, err := client.Do(req)
	if err != nil {
		log.Logger.Error("Failed to create user group" + err.Error())
		return
	}
	defer res.Body.Close()

	body, err := ioutil.ReadAll(res.Body)
	if err != nil {
		fmt.Println(err)
		return
	}
	fmt.Print(string(body))
	log.Logger.Info("create group result:" + string(body))
}

func GetGroupUsers(name string) (users map[string]string) {
	// TODO
	type Users struct {
		Login    string `json:"login"`
		Name     string `json:"name"`
		Selected bool   `json:"selected"`
	}
	type AutoGenerated struct {
		Users []Users `json:"users"`
		P     int     `json:"p"`
		Ps    int     `json:"ps"`
		Total int     `json:"total"`
	}

	result := make(map[string]string)

	page := 1
	pageSize := 100
	for {
		v := url.Values{}
		v.Add("name", name)
		v.Add("p", strconv.Itoa(page))
		v.Add("ps", strconv.Itoa(pageSize))
		v.Add("selected", "selected")

		url := flag.SonarAddr + "/api/user_groups/users?" + v.Encode()
		req, _ := http.NewRequest("GET", url, nil)
		req.Header.Add("Authorization", flag.SonarToken)

		resp, err := (&http.Client{}).Do(req)
		if err != nil {
			log.Logger.Error("Failed to query group user" + err.Error())
			return result
		}
		defer resp.Body.Close()
		respByte, _ := ioutil.ReadAll(resp.Body)
		var resultType AutoGenerated
		json.Unmarshal(respByte, &resultType)
		for _, e := range resultType.Users {
			result[e.Login] = e.Name
		}
		if page*pageSize >= resultType.Total {
			break
		}
		page++
	}
	return result
}

func IsExistUser(email string) (res bool) {
	// TODO
	type Paging struct {
		PageIndex int `json:"pageIndex"`
		PageSize  int `json:"pageSize"`
		Total     int `json:"total"`
	}
	type Users struct {
		Login              string   `json:"login"`
		Name               string   `json:"name"`
		Active             bool     `json:"active"`
		Email              string   `json:"email"`
		Groups             []string `json:"groups"`
		TokensCount        int      `json:"tokensCount"`
		Local              bool     `json:"local"`
		ExternalIdentity   string   `json:"externalIdentity"`
		ExternalProvider   string   `json:"externalProvider"`
		Avatar             string   `json:"avatar"`
		LastConnectionDate string   `json:"lastConnectionDate"`
	}
	type AutoGenerated struct {
		Paging Paging  `json:"paging"`
		Users  []Users `json:"users"`
	}

	res = false
	v := url.Values{}
	v.Add("q", email)

	url := flag.SonarAddr + "/api/users/search?" + v.Encode()
	method := "GET"
	req, err := http.NewRequest(method, url, nil)

	if err != nil {
		fmt.Println(err)
		return
	}
	req.Header.Add("Authorization", flag.SonarToken)
	resp, err := (&http.Client{}).Do(req)
	if err != nil {
		log.Logger.Error("Failed to query group user" + err.Error())
		return res
	}
	defer resp.Body.Close()
	respByte, _ := ioutil.ReadAll(resp.Body)
	var resultType AutoGenerated
	json.Unmarshal(respByte, &resultType)

	if nil != resultType.Users && len(resultType.Users) > 0 {
		for _, e := range resultType.Users {
			if e.Email == email {
				res = true
			}
		}
	}
	return res
}

func SearchUser() (response map[string]string) {
	type AutoGenerated struct {
		Paging struct {
			PageIndex int `json:"pageIndex"`
			PageSize  int `json:"pageSize"`
			Total     int `json:"total"`
		} `json:"paging"`
		Users []struct {
			Login              string   `json:"login"`
			Name               string   `json:"name"`
			Active             bool     `json:"active"`
			Groups             []string `json:"groups"`
			TokensCount        int      `json:"tokensCount"`
			Local              bool     `json:"local"`
			ExternalIdentity   string   `json:"externalIdentity"`
			ExternalProvider   string   `json:"externalProvider"`
			LastConnectionDate string   `json:"lastConnectionDate"`
			Email              string   `json:"email,omitempty"`
			Avatar             string   `json:"avatar,omitempty"`
		} `json:"users"`
	}

	result := make(map[string]string)
	page := 1
	pageSize := 100
	for {
		url := flag.SonarAddr + "/api/users/search?p=" + strconv.Itoa(page) + "&ps=" + strconv.Itoa(pageSize)
		req, _ := http.NewRequest("GET", url, nil)
		req.Header.Add("Authorization", flag.SonarToken)

		resp, err := (&http.Client{}).Do(req)
		if err != nil {
			log.Logger.Error("Failed to query user" + err.Error())
			return result
		}
		defer resp.Body.Close()
		respByte, _ := ioutil.ReadAll(resp.Body)
		var resultType AutoGenerated
		json.Unmarshal(respByte, &resultType)
		for _, e := range resultType.Users {
			if len(e.Email) > 0 {
				result[e.Email] = e.Login
			}
		}
		if page*pageSize >= resultType.Paging.Total {
			break
		}
		page++
	}
	return result
}

func AddUserToGroup(name string, login string) {
	// TODO
	method := "POST"
	v := url.Values{}
	v.Add("login", login)
	v.Add("name", name)
	reqUrl := flag.SonarAddr + "/api/user_groups/add_user?" + v.Encode()

	client := &http.Client{}
	req, err := http.NewRequest(method, reqUrl, nil)
	if err != nil {
		fmt.Println(err)
		return
	}
	req.Header.Add("Authorization", flag.SonarToken)
	res, err := client.Do(req)
	if err != nil {
		log.Logger.Error("Failed to addUserToGroup," + err.Error())
		return
	}
	defer res.Body.Close()

	body, err := ioutil.ReadAll(res.Body)
	if err != nil {
		fmt.Println(err)
		return
	}
	fmt.Print(string(body))
	log.Logger.Info("addUserToGroup result:" + string(body))
}

func RemoveUserToGroup(name string, login string) {
	// TODO
	method := "POST"
	v := url.Values{}
	v.Add("login", login)
	v.Add("name", name)
	reqUrl := flag.SonarAddr + "/api/user_groups/remove_user?" + v.Encode()

	client := &http.Client{}
	req, err := http.NewRequest(method, reqUrl, nil)
	if err != nil {
		fmt.Println(err)
		return
	}
	req.Header.Add("Authorization", flag.SonarToken)
	res, err := client.Do(req)
	if err != nil {
		log.Logger.Error("Failed to removeUserToGroup," + err.Error())
		return
	}
	defer res.Body.Close()

	body, err := ioutil.ReadAll(res.Body)
	if err != nil {
		fmt.Println(err)
		return
	}
	fmt.Print(string(body))
	log.Logger.Info("removeUserToGroup result:" + string(body))
}

// The queried result is the project identifier name with the regex suffix (:.*) removed
func SearchTemplates() (response map[string]string) {
	type AutoGenerated struct {
		PermissionTemplates []struct {
			ID          string `json:"id"`
			Name        string `json:"name"`
			Description string `json:"description"`
			CreatedAt   string `json:"createdAt"`
			UpdatedAt   string `json:"updatedAt"`
			Permissions []struct {
				Key                string `json:"key"`
				UsersCount         int    `json:"usersCount"`
				GroupsCount        int    `json:"groupsCount"`
				WithProjectCreator bool   `json:"withProjectCreator"`
			} `json:"permissions"`
			ProjectKeyPattern string `json:"projectKeyPattern,omitempty"`
		} `json:"permissionTemplates"`
		DefaultTemplates []struct {
			TemplateID string `json:"templateId"`
			Qualifier  string `json:"qualifier"`
		} `json:"defaultTemplates"`
		Permissions []struct {
			Key         string `json:"key"`
			Name        string `json:"name"`
			Description string `json:"description"`
		} `json:"permissions"`
	}
	result := make(map[string]string)
	url := flag.SonarAddr + "/api/permissions/search_templates"
	req, _ := http.NewRequest("GET", url, nil)
	req.Header.Add("Authorization", flag.SonarToken)

	resp, err := (&http.Client{}).Do(req)
	if err != nil {
		log.Logger.Error("Failed to query group user" + err.Error())
		return result
	}

	defer resp.Body.Close()
	respByte, _ := ioutil.ReadAll(resp.Body)
	var resultType AutoGenerated
	json.Unmarshal(respByte, &resultType)

	for _, e := range resultType.PermissionTemplates {
		if len(e.ProjectKeyPattern) > 0 && strings.Index(e.ProjectKeyPattern, ":.*") > 0 {
			namespace := strings.ReplaceAll(e.ProjectKeyPattern, ":.*", "")
			result[namespace] = e.ID
		}
	}
	return result
}

func CreateTemplate(name string, description string, projectKeyPattern string) (id string) {
	// TODO
	type PermissionTemplate struct {
		ID                string        `json:"id"`
		Name              string        `json:"name"`
		Description       string        `json:"description"`
		ProjectKeyPattern string        `json:"projectKeyPattern"`
		CreatedAt         string        `json:"createdAt"`
		UpdatedAt         string        `json:"updatedAt"`
		Permissions       []interface{} `json:"permissions"`
	}
	type AutoGenerated struct {
		PermissionTemplate PermissionTemplate `json:"permissionTemplate"`
	}

	method := "POST"
	v := url.Values{}
	v.Add("description", description)
	v.Add("name", name)
	v.Add("projectKeyPattern", projectKeyPattern)
	reqUrl := flag.SonarAddr + "/api/permissions/create_template?" + v.Encode()

	client := &http.Client{}
	req, err := http.NewRequest(method, reqUrl, nil)
	if err != nil {
		fmt.Println(err)
		return ""
	}
	req.Header.Add("Authorization", flag.SonarToken)
	res, err := client.Do(req)
	if err != nil {
		log.Logger.Error("Failed to createTemplate," + err.Error())
		return ""
	}
	defer res.Body.Close()

	body, err := ioutil.ReadAll(res.Body)
	if err != nil {
		fmt.Println(err)
		return ""
	}
	fmt.Print(string(body))
	log.Logger.Info("createTemplate result:" + string(body))

	var resultType AutoGenerated
	json.Unmarshal(body, &resultType)
	return resultType.PermissionTemplate.ID
}

func AddGroupToTemplate(templateId string, groupName string, permission string) {
	method := "POST"
	v := url.Values{}
	v.Add("templateId", templateId)
	v.Add("groupName", groupName)
	v.Add("permission", permission)
	reqUrl := flag.SonarAddr + "/api/permissions/add_group_to_template?" + v.Encode()

	client := &http.Client{}
	req, err := http.NewRequest(method, reqUrl, nil)
	if err != nil {
		fmt.Println(err)
		return
	}
	req.Header.Add("Authorization", flag.SonarToken)
	res, err := client.Do(req)
	if err != nil {
		log.Logger.Error("Failed to addGroupToTemplate," + err.Error())
		return
	}
	defer res.Body.Close()

	body, err := ioutil.ReadAll(res.Body)
	if err != nil {
		fmt.Println(err)
		return
	}
	fmt.Print(string(body))
	log.Logger.Info("addGroupToTemplate result:" + string(body))
}

func GetAllProjectsFromPG() (projects []sonar.Project, err error) {
	var p sonar.Project
	projects, err = p.List()
	if err != nil {
		fmt.Println(err)
		return
	}
	return
}

func GetAllProjects() (projects SonarProjects, err error) {
	method := "GET"
	//reqUrl := flag.SonarAddr + "/api/projects/search?ps=50&qualifiers=TRK"
	reqUrl := flag.SonarAddr + "/api/projects/search"
	fmt.Println("reqUrl: ", reqUrl)

	client := &http.Client{}
	req, err := http.NewRequest(method, reqUrl, nil)
	if err != nil {
		fmt.Println(err)
		return
	}
	fmt.Println("Authorization", flag.SonarToken)
	req.Header.Add("Authorization", flag.SonarToken)
	res, err := client.Do(req)
	if err != nil {
		log.Logger.Error("Failed to get project" + err.Error())
		return
	}
	if res.StatusCode != 200 {
		fmt.Println("res.StatusCode: ", res.StatusCode)
	}
	defer res.Body.Close()

	var body []byte
	body, err = io.ReadAll(res.Body)
	if err != nil {
		fmt.Println(err)
		return
	}
	//fmt.Println("body: ", body)
	fmt.Print(string(body))
	log.Logger.Info("get projects result:" + string(body))

	err = json.Unmarshal(body, &projects)
	if err != nil {
		fmt.Println(err)
		return
	}
	return
}

func GetProjectUsers(projectKey string) (projectUsers ProjectUsers, err error) {
	method := "GET"
	//reqUrl := flag.SonarAddr + "/api/permissions/users?ps=100&projectKey=devops.jojoops:backend:282"
	reqUrl := flag.SonarAddr + fmt.Sprintf("/api/permissions/users?ps=100&projectKey=%s", projectKey)
	//fmt.Println("reqUrl: ", reqUrl)

	client := &http.Client{}
	req, err := http.NewRequest(method, reqUrl, nil)
	if err != nil {
		fmt.Println(err)
		return
	}
	//fmt.Println("Authorization", flag.SonarToken)
	req.Header.Add("Authorization", flag.SonarToken)
	res, err := client.Do(req)
	if err != nil {
		log.Logger.Error("Failed to get project" + err.Error())
		return
	}
	if res.StatusCode != 200 {
		fmt.Println("res.StatusCode: ", res.StatusCode)
	}
	defer res.Body.Close()

	var body []byte
	body, err = io.ReadAll(res.Body)
	if err != nil {
		fmt.Println(err)
		return
	}
	//fmt.Println("body: ", body)
	//fmt.Print(string(body))
	//log.Logger.Info("get projects result:" + string(body))

	err = json.Unmarshal(body, &projectUsers)
	if err != nil {
		fmt.Println(err)
		return
	}

	return
}

func GetAllUsers() (users []User, err error) {
	var p = 1
	var ps = 500
	for {
		sonarUsers, _err := GetUsers(p, ps)
		if _err != nil {
			fmt.Println(_err)
			break
		}
		users = append(users, sonarUsers.Users...)
		if len(sonarUsers.Users) < ps {
			break
		}
		p += 1
	}

	return
}

func GetUsers(p, ps int) (users SonarUsers, err error) {
	method := "GET"
	reqUrl := flag.SonarAddr + fmt.Sprintf("/api/users/search?p=%v&ps=%v", p, ps)
	fmt.Println("reqUrl: ", reqUrl)

	client := &http.Client{}
	req, err := http.NewRequest(method, reqUrl, nil)
	if err != nil {
		fmt.Println(err)
		return
	}

	//fmt.Println("Authorization", flag.SonarToken)
	req.Header.Add("Authorization", flag.SonarToken)
	res, err := client.Do(req)
	if err != nil {
		log.Logger.Error("Failed to get user" + err.Error())
		return
	}
	if res.StatusCode != 200 {
		fmt.Println("res.StatusCode: ", res.StatusCode)
	}
	defer res.Body.Close()

	var body []byte
	body, err = io.ReadAll(res.Body)
	if err != nil {
		fmt.Println(err)
		return
	}
	//fmt.Println("body: ", body)
	//fmt.Print(string(body))
	//log.Logger.Info("get users result:" + string(body))

	err = json.Unmarshal(body, &users)
	if err != nil {
		fmt.Println(err)
		return
	}

	return
}

func AddUsersToProject(projectKey, login, permission string) (err error) {
	method := "POST"
	reqUrl := flag.SonarAddr + "/api/permissions/add_user"
	//fmt.Println("reqUrl: ", reqUrl)

	client := &http.Client{}

	// 创建一个缓冲区来保存 multipart 数据
	var requestBody bytes.Buffer
	writer := multipart.NewWriter(&requestBody)

	// 添加字段
	err = writer.WriteField("projectKey", projectKey)
	if err != nil {
		fmt.Printf("Error writing field: %v\n", err)
		return
	}
	err = writer.WriteField("login", login)
	if err != nil {
		fmt.Printf("Error writing field: %v\n", err)
		return
	}
	err = writer.WriteField("permission", permission)
	if err != nil {
		fmt.Printf("Error writing field: %v\n", err)
		return
	}

	// Close the writer to finalize the multipart data
	err = writer.Close()
	if err != nil {
		fmt.Printf("Error closing writer: %v\n", err)
		return
	}

	req, err := http.NewRequest(method, reqUrl, &requestBody)
	if err != nil {
		fmt.Println(err)
		return
	}

	req.Header.Add("Authorization", flag.SonarToken)
	// Set Content-Type header
	req.Header.Set("Content-Type", writer.FormDataContentType())

	res, err := client.Do(req)
	if err != nil {
		log.Logger.Error("Failed to get user" + err.Error())
		return
	}
	defer res.Body.Close()

	if res.StatusCode != 204 {
		body, _ := io.ReadAll(res.Body)
		err = errors.New(fmt.Sprintf("res.StatusCode: %v, body: %v", res.StatusCode, string(body)))
	}

	return
}

func RemoveUsersToProject(projectKey, login, permission string) (err error) {
	method := "POST"
	reqUrl := flag.SonarAddr + "/api/permissions/remove_user"
	//fmt.Println("reqUrl: ", reqUrl)

	client := &http.Client{}

	// Create a buffer to store multipart data
	var requestBody bytes.Buffer
	writer := multipart.NewWriter(&requestBody)

	// Add fields
	err = writer.WriteField("projectKey", projectKey)
	if err != nil {
		fmt.Printf("Error writing field: %v\n", err)
		return
	}
	err = writer.WriteField("login", login)
	if err != nil {
		fmt.Printf("Error writing field: %v\n", err)
		return
	}
	err = writer.WriteField("permission", permission)
	if err != nil {
		fmt.Printf("Error writing field: %v\n", err)
		return
	}

	// Close the writer to finalize the multipart data
	err = writer.Close()
	if err != nil {
		fmt.Printf("Error closing writer: %v\n", err)
		return
	}

	req, err := http.NewRequest(method, reqUrl, &requestBody)
	if err != nil {
		fmt.Println(err)
		return
	}

	req.Header.Add("Authorization", flag.SonarToken)
	// Set Content-Type header
	req.Header.Set("Content-Type", writer.FormDataContentType())

	res, err := client.Do(req)
	if err != nil {
		log.Logger.Error("Failed to get user" + err.Error())
		return
	}
	defer res.Body.Close()

	if res.StatusCode != 204 {
		body, _ := io.ReadAll(res.Body)
		err = errors.New(fmt.Sprintf("res.StatusCode: %v, body: %v", res.StatusCode, string(body)))
	}

	return
}

func AddGroupToProject(projectKey, groupName, permission string) (err error) {
	method := "POST"
	reqUrl := flag.SonarAddr + "/api/permissions/add_group"
	//fmt.Println("reqUrl: ", reqUrl)

	client := &http.Client{}

	// 创建一个缓冲区来保存 multipart 数据
	var requestBody bytes.Buffer
	writer := multipart.NewWriter(&requestBody)

	// 添加字段
	err = writer.WriteField("projectKey", projectKey)
	if err != nil {
		fmt.Printf("Error writing field: %v\n", err)
		return
	}
	err = writer.WriteField("groupName", groupName)
	if err != nil {
		fmt.Printf("Error writing field: %v\n", err)
		return
	}
	err = writer.WriteField("permission", permission)
	if err != nil {
		fmt.Printf("Error writing field: %v\n", err)
		return
	}

	// Close the writer to finalize the multipart data
	err = writer.Close()
	if err != nil {
		fmt.Printf("Error closing writer: %v\n", err)
		return
	}

	req, err := http.NewRequest(method, reqUrl, &requestBody)
	if err != nil {
		fmt.Println(err)
		return
	}

	req.Header.Add("Authorization", flag.SonarToken)
	// Set Content-Type header
	req.Header.Set("Content-Type", writer.FormDataContentType())

	res, err := client.Do(req)
	if err != nil {
		log.Logger.Error("Failed to get user" + err.Error())
		return
	}
	defer res.Body.Close()

	if res.StatusCode != 204 {
		body, _ := io.ReadAll(res.Body)
		err = errors.New(fmt.Sprintf("res.StatusCode: %v, body: %v", res.StatusCode, string(body)))
	}

	return
}

func RemoveGroupToProject(projectKey, groupName, permission string) (err error) {
	method := "POST"
	reqUrl := flag.SonarAddr + "/api/permissions/remove_group"
	//fmt.Println("reqUrl: ", reqUrl)

	client := &http.Client{}

	// 创建一个缓冲区来保存 multipart 数据
	var requestBody bytes.Buffer
	writer := multipart.NewWriter(&requestBody)

	// 添加字段
	err = writer.WriteField("projectKey", projectKey)
	if err != nil {
		fmt.Printf("Error writing field: %v\n", err)
		return
	}
	err = writer.WriteField("groupName", groupName)
	if err != nil {
		fmt.Printf("Error writing field: %v\n", err)
		return
	}
	err = writer.WriteField("permission", permission)
	if err != nil {
		fmt.Printf("Error writing field: %v\n", err)
		return
	}

	// Close the writer to finalize the multipart data
	err = writer.Close()
	if err != nil {
		fmt.Printf("Error closing writer: %v\n", err)
		return
	}

	req, err := http.NewRequest(method, reqUrl, &requestBody)
	if err != nil {
		fmt.Println(err)
		return
	}

	req.Header.Add("Authorization", flag.SonarToken)
	// Set Content-Type header
	req.Header.Set("Content-Type", writer.FormDataContentType())

	res, err := client.Do(req)
	if err != nil {
		log.Logger.Error("Failed to get user" + err.Error())
		return
	}
	defer res.Body.Close()

	if res.StatusCode != 204 {
		body, _ := io.ReadAll(res.Body)
		err = errors.New(fmt.Sprintf("res.StatusCode: %v, body: %v", res.StatusCode, string(body)))
	}

	return
}

type SonarUsers struct {
	Paging Page   `json:"paging"`
	Users  []User `json:"users"`
}

type User struct {
	Login              string   `json:"login"`
	Name               string   `json:"name"`
	Active             bool     `json:"active"`
	Groups             []string `json:"groups"`
	TokensCount        int      `json:"tokensCount"`
	Local              bool     `json:"local"`
	ExternalIdentity   string   `json:"externalIdentity"`
	ExternalProvider   string   `json:"externalProvider"`
	LastConnectionDate string   `json:"lastConnectionDate,omitempty"`
	Managed            bool     `json:"managed"`
	Email              string   `json:"email,omitempty"`
	Avatar             string   `json:"avatar,omitempty"`
}

type SonarProjects struct {
	Paging     Page      `json:"paging"`
	Components []Project `json:"components"`
}

type Page struct {
	PageIndex int `json:"pageIndex"`
	PageSize  int `json:"pageSize"`
	Total     int `json:"total"`
}

type Project struct {
	Key              string `json:"key"`
	Name             string `json:"name"`
	Qualifier        string `json:"qualifier"`
	Visibility       string `json:"visibility"`
	LastAnalysisDate string `json:"lastAnalysisDate,omitempty"`
	Revision         string `json:"revision,omitempty"`
}

type ProjectUsers struct {
	Paging Page          `json:"paging"`
	Users  []ProjectUser `json:"users"`
}

type ProjectUser struct {
	Login       string   `json:"login"`
	Name        string   `json:"name"`
	Email       string   `json:"email"`
	Permissions []string `json:"permissions"`
	Avatar      string   `json:"avatar,omitempty"`
	Managed     bool     `json:"managed"`
}
